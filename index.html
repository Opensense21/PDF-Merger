<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Manager</title>
    <!-- Existing Libraries -->
    <script src="https://unpkg.com/pdf-lib@1.17.0/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Include pdf.js library -->
    <!-- Core library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Specify the worker script URL -->
    <script>
        // Set the workerSrc property to the URL of the worker script
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 95vh;
            margin: 0;
            background: linear-gradient(to bottom right, #f5f0ff, #e0f2f7); /* Soft pastel gradient */
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            color: #6a1b9a; /* Deep purple */
            margin-bottom: 20px;
            font-weight: 700;
        }

        #dropZone {
            width: 80%;
            max-width: 700px;
            height: 200px;
            border: 2px dashed #b39ddb; /* Pastel purple */
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 30px 0;
            background-color: #ede7f6; /* Very light purple */
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 1.2em;
            color: #6a1b9a;
        }
        #dropZone:hover {
            border-color: #9575cd; /* Lighter purple */
            background-color: #d1c4e9; /* Light purple */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        #fileList {
            width: 80%;
            max-width: 700px;
            margin: 10px 0;
            list-style: none;
            padding: 0;
        }

        .file-item-container {
            margin-bottom: 15px; /* Add margin between file items */
            background-color: #fff; /* White background for the whole item container */
            border-radius: 10px;
            border: 1px solid #e1bee7; /* Pastel pink-purple */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            overflow: hidden; /* Contain internal elements */
        }

        .file-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            cursor: grab; /* Indicate draggable area */
            background-color: #fff; /* White */
            transition: all 0.2s ease;
        }
        .file-item-header:hover {
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .file-item-header.sortable-drag {
            opacity: 0.5; /* Feedback during drag */
        }

        .file-item-info {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .file-item-info span {
            flex-shrink: 0; /* Prevent shrinking */
        }

        .file-item-info input[type="text"] {
            flex-grow: 1;
            margin: 0 15px;
            padding: 5px;
            max-width: 200px; /* Limit input width */
            border: 1px solid #e1bee7;
            border-radius: 5px;
            font-size: 0.9em;
            color: #555;
        }

        .file-actions {
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .toggle-preview-button {
            background: none;
            border: none;
            color: #6a1b9a; /* Deep purple */
            font-size: 1em;
            margin-right: 10px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s ease;
        }
        .toggle-preview-button:hover {
             color: #4a148c; /* Darker purple */
        }

        .remove-button {
             background-color: #ef9a9a; /* Pastel red */
             color: #333; /* Dark text for contrast */
             border: none;
             border-radius: 5px;
             padding: 5px 10px;
             font-size: 0.9em;
             margin-left: 5px; /* Small margin from toggle button */
             cursor: pointer;
             transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .remove-button:hover {
             background-color: #e57373; /* Slightly darker pastel red */
             transform: translateY(-1px);
        }


        /* Preview Section Styling */
        .preview-container {
            padding: 0 15px 15px 15px; /* Add padding around previews */
            border-top: 1px solid #eee; /* Separator line */
            background-color: #f3e5f5; /* Very light purple background for previews */
            transition: max-height 0.3s ease-in-out; /* Smooth collapse/expand */
            max-height: 0; /* Start collapsed */
            overflow: hidden;
        }

        .preview-container.expanded {
             max-height: 500px; /* Sufficient height for expanded state, adjust if needed */
             padding-top: 15px; /* Add padding back when expanded */
             overflow-y: auto; /* Allow vertical scrolling if previews are very tall */
        }


        .preview-list {
            display: flex;
            overflow-x: auto; /* Enable horizontal scrolling */
            padding-bottom: 10px; /* Space for scrollbar */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on touch devices */
        }
        .preview-list::-webkit-scrollbar {
            height: 8px;
        }
        .preview-list::-webkit-scrollbar-track {
            background: #e1bee7; /* Pastel pink-purple */
            border-radius: 10px;
        }
        .preview-list::-webkit-scrollbar-thumb {
            background: #ab47bc; /* Medium purple */
            border-radius: 10px;
        }
        .preview-list::-webkit-scrollbar-thumb:hover {
            background: #8e24aa; /* Darker purple */
        }


        .page-preview {
            margin-right: 15px; /* Space between thumbnails */
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking of thumbnail items */
            border: 1px solid #ce93d8; /* Light purple border */
            border-radius: 8px;
            padding: 5px;
            background-color: #fff; /* White background for each thumbnail item */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .page-preview canvas {
            display: block; /* Remove extra space below canvas */
            border-radius: 5px; /* Match parent border-radius */
        }

        .page-preview span {
            display: block;
            margin-top: 5px;
            font-size: 0.8em;
            color: #4527a0; /* Dark purple */
            font-weight: 500;
        }


        /* Operation Buttons & Inputs */
        #operationSection {
            margin: 20px 0;
            padding: 20px;
            background-color: #f3e5f5; /* Very light purple */
            border-radius: 10px;
            border: 1px solid #e1bee7;
            width: 80%;
            max-width: 700px;
            text-align: center;
        }

        #operationSection button,
        #operationSection select {
            margin: 8px; /* Adjust margin for spacing */
            padding: 10px 15px; /* Adjust padding */
            font-size: 0.95em;
        }

        #operationSection label {
            display: inline-block;
            margin: 10px 5px;
            font-weight: 600;
            color: #4527a0; /* Dark purple */
        }

        #outputName, #watermark {
             width: 200px; /* Consistent width */
             padding: 8px;
             margin: 8px;
        }


        button {
            padding: 10px 20px;
            margin: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            background-color: #b39ddb; /* Pastel purple */
            color: #333;
            border: none;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        button:hover:not(:disabled) {
            background-color: #9575cd; /* Lighter purple */
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        input[type="file"] {
            display: none;
        }

        #outputName, #watermark, select {
            padding: 8px; /* Slightly increased padding */
            margin: 8px 10px;
            width: 220px;
            border: 1px solid #e1bee7;
            border-radius: 5px;
            font-size: 1em;
            box-sizing: border-box; /* Include padding/border in width */
        }
         select {
             width: 100px; /* Specific width for select */
         }


        #progress {
            display: none;
            margin: 20px auto; /* Center progress */
            width: 40px;
            height: 40px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #7e57c2; /* Medium purple */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        label {
            margin-right: 5px;
            font-weight: 600; /* Slightly bolder */
            color: #4527a0; /* Dark purple */
        }
    </style>
</head>
<body>
    <h1>PDF Manager</h1>
    <div id="dropZone">
        <i class="fas fa-file-upload fa-3x" style="color: #9575cd;"></i>
        <p>Drag & Drop PDFs or Click to Upload</p>
    </div>
    <input type="file" id="fileInput" accept="application/pdf" multiple>
    <div id="fileList"></div>

    <div id="operationSection" style="display: none;">
        <label>Operation:</label>
        <button id="mergeButton" disabled><i class="fas fa-code-merge"></i> Merge</button>
        <button id="splitButton" disabled><i class="fas fa-scissors"></i> Split Pages</button>
        <button id="rotateButton" disabled><i class="fas fa-rotate"></i> Rotate Pages</button>
        <select id="rotateAngle">
            <option value="90">90°</option>
            <option value="180">180°</option>
            <option value="270">270°</option>
        </select>
        <br>
        <label for="outputName">Output Filename:</label>
        <input type="text" id="outputName" placeholder="e.g., merged.pdf" value="merged.pdf">
        <br>
        <label for="watermark">Watermark (optional):</label>
        <input type="text" id="watermark" placeholder="Enter watermark text">
    </div>
    <div id="progress"></div>
    <button id="startOverButton"><i class="fas fa-redo"></i> Start Over</button>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const mergeButton = document.getElementById('mergeButton');
        const splitButton = document.getElementById('splitButton');
        const rotateButton = document.getElementById('rotateButton');
        const rotateAngle = document.getElementById('rotateAngle');
        const outputNameInput = document.getElementById('outputName');
        const watermarkInput = document.getElementById('watermark');

        const operationSection = document.getElementById('operationSection');
        const progress = document.getElementById('progress');
        const startOverButton = document.getElementById('startOverButton');

        // Store file data including the pdf.js document and original file object
        let pdfFiles = []; // Structure: { id: uniqueId, file: File, pdfLibDoc: PDFLib.PDFDocument, pdfjsDoc: pdfjsLib.PDFDocument, pageCount: number, pages: string, element: HTMLElement }


        // Initialize drag-and-drop sorting on the file *item containers*
        new Sortable(fileList, {
            animation: 150,
            handle: '.file-item-header', // Make only the header draggable
            onEnd: () => {
                // Reorder the pdfFiles array based on the new order of DOM elements
                const newOrderElements = Array.from(fileList.children);
                const newOrderFiles = [];
                newOrderElements.forEach(itemElement => {
                     const fileId = itemElement.dataset.fileId;
                     const fileData = pdfFiles.find(f => f.id === fileId);
                     if (fileData) {
                        newOrderFiles.push(fileData);
                     }
                });
                pdfFiles = newOrderFiles;
                // console.log('New order:', pdfFiles.map(f => f.file.name)); // Optional: log new order
            }
        });

        // Handle click to open file input
        dropZone.addEventListener('click', () => fileInput.click());

        // Handle file selection from input
        fileInput.addEventListener('change', handleFiles);

        // Handle drag and drop events
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover'); // Optional: Add visual feedback class
        });

        dropZone.addEventListener('dragleave', () => {
             dropZone.classList.remove('dragover'); // Optional: Remove visual feedback class
        });

         dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover'); // Optional: Remove visual feedback class
            handleFiles(e);
        });

        async function handleFiles(e) {
            const files = e.target.files || e.dataTransfer.files;
             // Convert FileList to array and filter non-PDFs early
            const pdfFilesToProcess = Array.from(files).filter(file => file.type === 'application/pdf');

            if (pdfFilesToProcess.length === 0) return; // No PDF files selected

            // Simple check if any files already exist with the same name
            const existingNames = new Set(pdfFiles.map(f => f.file.name));
             const newFiles = pdfFilesToProcess.filter(file => !existingNames.has(file.name));

            if (newFiles.length < pdfFilesToProcess.length) {
                 alert('Some selected files were already added.');
            }

            progress.style.display = 'block'; // Show progress indicator

            for (const file of newFiles) {
                try {
                    const arrayBuffer = await file.arrayBuffer();

                    // Use pdf-lib for structure/page count
                    const pdfLibDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                    const pageCount = pdfLibDoc.getPageCount();

                    // Use pdf.js for rendering previews
                    const pdfjsDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                    // Generate a unique ID for the file item
                    const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                    const fileData = {
                        id: fileId,
                        file: file,
                        pdfLibDoc: pdfLibDoc,
                        pdfjsDoc: pdfjsDoc, // Store pdfjs document object
                        pageCount: pageCount,
                        pages: '', // Page range input value
                        element: null // Will store the created DOM element
                    };

                    pdfFiles.push(fileData);
                    await displayFile(fileData); // Pass the entire fileData object

                } catch (error) {
                     console.error("Error processing file:", file.name, error);
                     alert(`Could not process file "${file.name}". Make sure it is a valid PDF.`);
                }
            }

             progress.style.display = 'none'; // Hide progress indicator
            updateUI();

             // Clear the file input so selecting the same file again triggers 'change'
             e.target.value = '';
        }

        async function displayFile(fileData) {
            const { id, file, pageCount } = fileData;

            const container = document.createElement('div');
            container.className = 'file-item-container';
            container.dataset.fileId = id; // Store ID on the container

            const header = document.createElement('div');
            header.className = 'file-item-header';

            const info = document.createElement('div');
            info.className = 'file-item-info';

            const fileNameSpan = document.createElement('span');
            fileNameSpan.textContent = `${file.name} (${pageCount} pages)`;

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'e.g., 1-3, 5';
            input.dataset.fileId = id; // Use ID instead of filename
            input.addEventListener('input', (e) => { // Use 'input' for immediate validation feedback
                const item = pdfFiles.find(f => f.id === id);
                item.pages = e.target.value;
                // Optional: Add visual feedback to the input or item if validation fails
                try {
                    parsePageRanges(item.pages, item.pageCount);
                    e.target.style.borderColor = '#e1bee7'; // Reset border color on success
                } catch {
                    e.target.style.borderColor = '#e57373'; // Highlight invalid input
                }
                updateUI(); // Update button states
            });


            const actions = document.createElement('div');
            actions.className = 'file-actions';

            const togglePreviewBtn = document.createElement('button');
            togglePreviewBtn.className = 'toggle-preview-button';
            togglePreviewBtn.innerHTML = `<i class="fas fa-chevron-down"></i>`; // Initial icon
            togglePreviewBtn.title = 'Show Previews';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-button';
            removeBtn.innerHTML = `<i class="fas fa-times"></i>`;
            removeBtn.title = 'Remove File';
            removeBtn.addEventListener('click', () => removeFile(id)); // Remove by ID

            info.appendChild(fileNameSpan);
            info.appendChild(input);

            actions.appendChild(togglePreviewBtn);
            actions.appendChild(removeBtn);

            header.appendChild(info);
            header.appendChild(actions);


            // Preview Container
            const previewContainer = document.createElement('div');
            previewContainer.className = 'preview-container';
            // Initially collapsed by default CSS


            // Preview List (horizontal scrolling)
            const previewList = document.createElement('div');
            previewList.className = 'preview-list';
            previewContainer.appendChild(previewList);


            container.appendChild(header);
            container.appendChild(previewContainer);

            fileList.appendChild(container);

            // Store reference to the created DOM element
            fileData.element = container;

            // Toggle logic
            let isExpanded = false;
            togglePreviewBtn.addEventListener('click', async () => {
                isExpanded = !isExpanded;
                if (isExpanded) {
                    previewContainer.classList.add('expanded');
                    togglePreviewBtn.innerHTML = `<i class="fas fa-chevron-up"></i>`;
                    togglePreviewBtn.title = 'Hide Previews';
                    // Render previews only when expanding for the first time
                    if (previewList.childElementCount === 0) {
                         progress.style.display = 'block'; // Show progress during rendering
                        await renderPreviews(fileData, previewList);
                         progress.style.display = 'none'; // Hide progress
                    }
                } else {
                    previewContainer.classList.remove('expanded');
                    togglePreviewBtn.innerHTML = `<i class="fas fa-chevron-down"></i>`;
                    togglePreviewBtn.title = 'Show Previews';
                }
            });


            // Initial validation check for empty input
            validatePageRangesForFile(id);
        }

        async function renderPreviews(fileData, previewListElement) {
             const { pdfjsDoc, pageCount } = fileData;
             const thumbnailHeight = 180; // px

             // Clear existing previews if any (though we expect this to be called only once)
             previewListElement.innerHTML = '';

             for (let i = 1; i <= pageCount; i++) {
                 try {
                     const page = await pdfjsDoc.getPage(i);
                     const viewport = page.getViewport({ scale: thumbnailHeight / page.getViewport({ scale: 1 }).height });

                     const pagePreviewDiv = document.createElement('div');
                     pagePreviewDiv.className = 'page-preview';

                     const canvas = document.createElement('canvas');
                     const context = canvas.getContext('2d');
                     canvas.height = viewport.height;
                     canvas.width = viewport.width;

                     const renderContext = {
                         canvasContext: context,
                         viewport: viewport
                     };

                     await page.render(renderContext).promise;

                     const pageNumberSpan = document.createElement('span');
                     pageNumberSpan.textContent = `Page ${i}`;

                     pagePreviewDiv.appendChild(canvas);
                     pagePreviewDiv.appendChild(pageNumberSpan);

                     previewListElement.appendChild(pagePreviewDiv);

                 } catch (error) {
                     console.error(`Error rendering page ${i} for ${fileData.file.name}:`, error);
                     // Optionally display an error placeholder instead of the canvas
                     const pagePreviewDiv = document.createElement('div');
                     pagePreviewDiv.className = 'page-preview';
                     pagePreviewDiv.style.width = `${thumbnailHeight * 0.7}px`; // Placeholder width
                     pagePreviewDiv.style.height = `${thumbnailHeight + 20}px`; // Placeholder height
                     pagePreviewDiv.innerHTML = `<span>Page ${i}<br>(Error)</span>`;
                     pagePreviewDiv.style.display = 'flex';
                     pagePreviewDiv.style.flexDirection = 'column';
                     pagePreviewDiv.style.justifyContent = 'center';
                     pagePreviewDiv.style.alignItems = 'center';
                     pagePreviewDiv.style.color = '#c62828'; // Reddish error color
                     pagePreviewDiv.style.border = '1px dashed #ef9a9a';
                     previewListElement.appendChild(pagePreviewDiv);
                 }
             }
        }


        function removeFile(fileId) {
            const fileDataIndex = pdfFiles.findIndex(f => f.id === fileId);
            if (fileDataIndex > -1) {
                const fileData = pdfFiles[fileDataIndex];
                // Remove the DOM element
                if (fileData.element && fileData.element.parentNode) {
                    fileData.element.parentNode.removeChild(fileData.element);
                }
                // Remove from the array
                pdfFiles.splice(fileDataIndex, 1);
                // Clean up pdfjs document (optional, but good practice)
                if (fileData.pdfjsDoc) {
                    fileData.pdfjsDoc.destroy().catch(e => console.error('Error destroying pdfjs document:', e));
                }
                 updateUI();
            }
        }

        function updateUI() {
            operationSection.style.display = pdfFiles.length > 0 ? 'block' : 'none';

             // Validate all files for merge
             const canMerge = pdfFiles.length >= 1 && pdfFiles.every(f => validatePageRangesForFile(f.id));
             mergeButton.disabled = !canMerge;

            // Validate single file selection and its page range for split/rotate
            const canSplitOrRotate = pdfFiles.length === 1 && validatePageRangesForFile(pdfFiles[0].id);
            splitButton.disabled = !canSplitOrRotate;
            rotateButton.disabled = !canSplitOrRotate;
        }

        // Validates page ranges for a specific file by ID
        function validatePageRangesForFile(fileId) {
            const file = pdfFiles.find(f => f.id === fileId);
            if (!file) return false;
            if (!file.pages) return true; // Empty means all pages, which is valid

            try {
                const indices = parsePageRanges(file.pages, file.pageCount);
                // Check if parsing returns *any* valid indices
                return indices.length > 0;
            } catch {
                return false; // Parsing failed
            }
        }

        function parsePageRanges(range, pageCount) {
             if (!range) return Array.from({ length: pageCount }, (_, i) => i); // Return 0-based indices
             const indices = [];
             const parts = range.split(',').map(p => p.trim()).filter(p => p !== ''); // Filter out empty parts

             if (parts.length === 0 && range.trim() !== '') {
                  // If range had commas but no valid parts (e.g., ",,"), it's invalid
                  throw new Error('Invalid range format');
             }
             if (parts.length === 0 && range.trim() === '') {
                  return Array.from({ length: pageCount }, (_, i) => i); // Empty input means all pages
             }


            for (const part of parts) {
                if (part.includes('-')) {
                    const [startStr, endStr] = part.split('-').map(n => n.trim());
                    const start = parseInt(startStr);
                    const end = parseInt(endStr);

                    // Check if parsing to number failed or if range is invalid
                    if (isNaN(start) || isNaN(end) || start < 1 || end > pageCount || start > end) {
                        throw new Error(`Invalid range "${part}"`);
                    }
                    for (let i = start; i <= end; i++) {
                        indices.push(i - 1); // Convert to 0-based index
                    }
                } else {
                    const num = parseInt(part);
                    // Check if parsing to number failed or if page number is out of bounds
                    if (isNaN(num) || num < 1 || num > pageCount) {
                        throw new Error(`Invalid page number "${part}"`);
                    }
                    indices.push(num - 1); // Convert to 0-based index
                }
            }
            // Remove duplicates and sort
            return [...new Set(indices)].sort((a, b) => a - b);
        }

        async function addWatermark(pdfDoc, text) {
            if (!text) return;
            try {
                const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                const pages = pdfDoc.getPages();
                 // Apply watermark to selected pages if page range is specified for this document (for split/rotate),
                 // otherwise apply to all pages (for merge where we create a new doc).
                 // NOTE: This assumes watermark on merge applies to ALL pages of the *new* merged doc.
                 // If you needed watermarking only specific pages *from the original files*, that's more complex.
                 // For simplicity, we'll apply to all pages of the resulting document.

                for (const page of pages) {
                    const { width, height } = page.getSize();
                    page.drawText(text, {
                        x: width / 4, // Slightly off-center
                        y: height / 2,
                        size: 40, // Slightly smaller size
                        font,
                        color: PDFLib.rgb(0.6, 0.6, 0.6), // Lighter gray
                        opacity: 0.4, // Slightly more opaque
                        rotate: PDFLib.degrees(45),
                         // Optional: positionRelativeTo: PDFLib.RelativeTo.TopLeft or PDFLib.RelativeTo.BottomLeft
                    });
                }
            } catch (error) {
                 console.error("Error adding watermark:", error);
                 alert("Could not add watermark. " + error.message);
                 // Decide if you want to proceed without watermark or stop the operation
                 // For now, we'll let the operation continue without the watermark
            }
        }

        mergeButton.addEventListener('click', async () => {
            if (!validatePageRanges()) {
                 alert("Please fix invalid page range inputs.");
                 return;
            }
            progress.style.display = 'block';
            try {
                const mergedPdf = await mergePDFs();
                const filename = outputNameInput.value.trim() || 'merged';
                const finalFilename = filename.endsWith('.pdf') ? filename : `${filename}.pdf`;
                const blob = new Blob([mergedPdf], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFilename;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error("Error merging PDFs:", error);
                alert('Error merging PDFs: ' + error.message);
            }
            progress.style.display = 'none';
        });

        async function mergePDFs() {
            const mergedPdfDoc = await PDFLib.PDFDocument.create();
            const watermarkText = watermarkInput.value.trim();

            for (const { pdfLibDoc, pages, pageCount } of pdfFiles) {
                // Note: pdfLibDoc is already loaded from the original arrayBuffer
                const pageIndices = parsePageRanges(pages, pageCount);
                // pageIndices are 0-based for pdf-lib copyPages

                if (pageIndices.length > 0) { // Only copy if valid pages selected
                    const copiedPages = await mergedPdfDoc.copyPages(pdfLibDoc, pageIndices);
                    copiedPages.forEach(page => mergedPdfDoc.addPage(page));
                } else if (pages.trim() !== '') {
                     // This case means input was invalid, but validatePageRanges() should prevent reaching here
                     console.warn(`File skipped due to invalid or empty page range "${pages}" after validation.`);
                }
            }

             // Add watermark to the final merged document
            await addWatermark(mergedPdfDoc, watermarkText);

            return await mergedPdfDoc.save();
        }

        splitButton.addEventListener('click', async () => {
            if (pdfFiles.length !== 1) return; // Should be disabled by UI update
            const { id, pdfLibDoc, pages, pageCount } = pdfFiles[0];
            if (!validatePageRangesForFile(id)) {
                 alert("Please fix the invalid page range input.");
                 return;
            }

            progress.style.display = 'block';
            try {
                const zip = new JSZip();
                const pageIndices = parsePageRanges(pages, pageCount); // 0-based indices
                 const watermarkText = watermarkInput.value.trim();

                if (pageIndices.length === 0 && pages.trim() !== '') {
                     alert("No valid pages selected for splitting.");
                     progress.style.display = 'none';
                     return;
                }

                for (const pageIndex of pageIndices) {
                    const newPdf = await PDFLib.PDFDocument.create();
                    // Copy the page using its 0-based index
                    const [copiedPage] = await newPdf.copyPages(pdfLibDoc, [pageIndex]);
                    newPdf.addPage(copiedPage);

                    // Add watermark to each split page
                    await addWatermark(newPdf, watermarkText);

                    const pdfBytes = await newPdf.save();
                    // Zip file name uses 1-based page number
                    zip.file(`${pdfFiles[0].file.name.replace('.pdf', '')}_page_${pageIndex + 1}.pdf`, pdfBytes);
                 }

                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const filename = outputNameInput.value.trim() || 'split';
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.zip`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error("Error splitting PDF:", error);
                alert('Error splitting PDF: ' + error.message);
            }
            progress.style.display = 'none';
        });

        rotateButton.addEventListener('click', async () => {
            if (pdfFiles.length !== 1) return; // Should be disabled by UI update
             const { id, pdfLibDoc, pages, pageCount } = pdfFiles[0];
             if (!validatePageRangesForFile(id)) {
                 alert("Please fix the invalid page range input.");
                 return;
             }

            progress.style.display = 'block';
            try {
                // Work directly on the loaded pdfLibDoc
                const pageIndices = parsePageRanges(pages, pageCount); // 0-based indices
                const angle = parseInt(rotateAngle.value);
                 const watermarkText = watermarkInput.value.trim();

                if (pageIndices.length === 0 && pages.trim() !== '') {
                     alert("No valid pages selected for rotation.");
                     progress.style.display = 'none';
                     return;
                }

                for (const index of pageIndices) {
                    const page = pdfLibDoc.getPage(index); // Get page by 0-based index
                    const currentRotation = page.getRotation().angle || 0; // Get current rotation, default to 0
                    page.setRotation(PDFLib.degrees(currentRotation + angle));
                }

                 // Add watermark after rotation
                 await addWatermark(pdfLibDoc, watermarkText);

                const pdfBytes = await pdfLibDoc.save(); // Save the modified document
                const filename = outputNameInput.value.trim() || 'rotated';
                const finalFilename = filename.endsWith('.pdf') ? filename : `${filename}.pdf`;
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFilename;
                a.click();
                URL.revokeObjectURL(url);

                 // Optional: Re-render previews after rotation if the preview is currently visible
                 // This is complex as it requires re-loading the pdfjsDoc or updating the canvases.
                 // For simplicity, we won't auto-update the preview, but the output file is correct.
                 // A more advanced version might regenerate previews for the rotated file.

            } catch (error) {
                console.error("Error rotating PDF:", error);
                alert('Error rotating PDF: ' + error.message);
            }
            progress.style.display = 'none';
        });


        startOverButton.addEventListener('click', () => {
             // Destroy pdfjs documents to free memory
             pdfFiles.forEach(fileData => {
                 if (fileData.pdfjsDoc) {
                     fileData.pdfjsDoc.destroy().catch(e => console.error('Error destroying pdfjs document on reset:', e));
                 }
             });
            pdfFiles = [];
            fileList.innerHTML = '';
            outputNameInput.value = 'merged.pdf';
            watermarkInput.value = '';
            updateUI();
        });

        // Initial UI state update
        updateUI();

    </script>
</body>
</html>
